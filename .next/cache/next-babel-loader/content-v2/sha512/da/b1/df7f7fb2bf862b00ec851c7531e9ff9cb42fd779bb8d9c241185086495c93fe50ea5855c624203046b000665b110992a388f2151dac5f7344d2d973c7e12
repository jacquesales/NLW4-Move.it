{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/jacqueline/Documents/NLW4/moveit-next/src/contexts/CountdownContext.tsx\";\n// Regras de negócio da aplicação; Funções do countdown serão acessadas por outros componentes da aplicação:\nimport { createContext, useContext, useEffect, useState } from \"react\"; // useEffect é um hook de efeitos colaterais: quando algo acontecer é disparada alguma função \n\nimport { ChallengesContext } from \"./ChallengesContext\";\nexport const CountdownContext = /*#__PURE__*/createContext({});\nlet countdownTimeout; // tipagem global da variável para definir qual o formato dela\n\nexport function CountdownProvider({\n  children\n}) {\n  // o countdown que iniciará um novo challenge\n  const {\n    startNewChallenge\n  } = useContext(ChallengesContext); // desestruturando o contexto\n\n  const {\n    0: time,\n    1: setTime\n  } = useState(25 * 60); // tempo inicial do countdown em segundos\n\n  const {\n    0: isActive,\n    1: setIsActive\n  } = useState(); // armazena a informação de quando o countdown está acontecendo/ativo\n\n  const {\n    0: hasFinished,\n    1: setHasFinished\n  } = useState(false); // inicia como false porque essa condição será setada depois \n\n  const minutes = Math.floor(time / 60); // arredondando pra baixo, desconsiderando segundos restantes\n\n  const seconds = time % 60; // resto da divisão pra considerar os segundos restantes \n\n  function startCountdown() {\n    setIsActive(true); // no começo precisa ativar o countdown, então ao clicar no botão será setado o valor\n  } // a função tem o objetivo de suspender, então partir desse momento vai parar de executar\n\n\n  function resetCountdown() {\n    // porém quando parar o countdown, a função abaixo já terá executado - 1, nesse caso incluir a variável countdownTimeout pra tratar esse detalhe    \n    clearTimeout(countdownTimeout); // quando resetar o countdown, dar um clear passando a variável countdownTimeout cancelando assim sua execução\n\n    setIsActive(false); // parando de executar\n\n    setHasFinished(false); // voltando para a condição inicial do countdown\n\n    setTime(25 * 60); // quando for parado o countdown, o setTime deve ser atualizado e o time deve voltar para seu estado inicial\n  } // 1º parâmetro: função do que quero executar, 2º parâmetro: quando quero executar\n  // nesse caso executar a função startCountDown sempre que o valor de active mudar\n\n\n  useEffect(() => {\n    if (isActive && time > 0) {\n      // se estou com countdown ativo e time for maior que 0\n      countdownTimeout = setTimeout(() => {\n        // a variável irá armazenar a função nativa setTimeout dispara outra função aqui uma arrow function, no tempo que for definido, nesse caso, 1 segundo\n        setTime(time - 1); // essa arrow function tira 1 segundo do time e atualiza o setTime \n      }, 1000);\n    } else if (isActive && time === 0) {\n      // verificando se o countdown chegou até o final\n      setHasFinished(true); // aqui o estado setHasFinished será atualizado\n\n      setIsActive(false); // e o contdown não estará mais ativo\n\n      startNewChallenge(); // quando o time chega a 0, a função startNewChallenge irá disparar um novo desafio\n    }\n  }, [isActive, time]); // além de xecutar toda essa função quando o active mudar, executar também quando o time muda (a cada 1 segundo a função é disparada)\n\n  return /*#__PURE__*/_jsxDEV(CountdownContext.Provider, {\n    value: {\n      minutes,\n      seconds,\n      isActive,\n      hasFinished,\n      startCountdown,\n      resetCountdown\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 61,\n    columnNumber: 5\n  }, this);\n}","map":{"version":3,"sources":["/home/jacqueline/Documents/NLW4/moveit-next/src/contexts/CountdownContext.tsx"],"names":["createContext","useContext","useEffect","useState","ChallengesContext","CountdownContext","countdownTimeout","CountdownProvider","children","startNewChallenge","time","setTime","isActive","setIsActive","hasFinished","setHasFinished","minutes","Math","floor","seconds","startCountdown","resetCountdown","clearTimeout","setTimeout"],"mappings":";;AAAA;AAEA,SAASA,aAAT,EAAmCC,UAAnC,EAA+CC,SAA/C,EAA0DC,QAA1D,QAA0E,OAA1E,C,CAAmF;;AACnF,SAASC,iBAAT,QAAkC,qBAAlC;AAgBA,OAAO,MAAMC,gBAAgB,gBAAGL,aAAa,CAAC,EAAD,CAAtC;AAEP,IAAIM,gBAAJ,C,CAAuC;;AAEvC,OAAO,SAASC,iBAAT,CAA2B;AAAEC,EAAAA;AAAF,CAA3B,EAAiE;AACtE;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAwBR,UAAU,CAACG,iBAAD,CAAxC,CAFsE,CAET;;AAC7D,QAAM;AAAA,OAACM,IAAD;AAAA,OAAOC;AAAP,MAAkBR,QAAQ,CAAC,KAAK,EAAN,CAAhC,CAHsE,CAG3B;;AAC3C,QAAM;AAAA,OAACS,QAAD;AAAA,OAAWC;AAAX,MAA0BV,QAAQ,EAAxC,CAJsE,CAI1B;;AAC5C,QAAM;AAAA,OAACW,WAAD;AAAA,OAAcC;AAAd,MAAgCZ,QAAQ,CAAC,KAAD,CAA9C,CALsE,CAKf;;AACvD,QAAMa,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWR,IAAI,GAAG,EAAlB,CAAhB,CANsE,CAM/B;;AACvC,QAAMS,OAAO,GAAGT,IAAI,GAAG,EAAvB,CAPsE,CAO3C;;AAE3B,WAASU,cAAT,GAA0B;AACxBP,IAAAA,WAAW,CAAC,IAAD,CAAX,CADwB,CACL;AACpB,GAXqE,CAatE;;;AACA,WAASQ,cAAT,GAA0B;AAAE;AAC1BC,IAAAA,YAAY,CAAChB,gBAAD,CAAZ,CADwB,CACO;;AAC/BO,IAAAA,WAAW,CAAC,KAAD,CAAX,CAFwB,CAEJ;;AACpBE,IAAAA,cAAc,CAAC,KAAD,CAAd,CAHwB,CAGD;;AACvBJ,IAAAA,OAAO,CAAC,KAAK,EAAN,CAAP,CAJwB,CAIP;AAClB,GAnBqE,CAqBtE;AACA;;;AACAT,EAAAA,SAAS,CAAE,MAAM;AACf,QAAIU,QAAQ,IAAIF,IAAI,GAAG,CAAvB,EAA0B;AAAE;AAC1BJ,MAAAA,gBAAgB,GAAGiB,UAAU,CAAC,MAAM;AAAE;AACpCZ,QAAAA,OAAO,CAACD,IAAI,GAAG,CAAR,CAAP,CADkC,CACf;AACpB,OAF4B,EAE1B,IAF0B,CAA7B;AAGD,KAJD,MAIQ,IAAIE,QAAQ,IAAIF,IAAI,KAAK,CAAzB,EAA4B;AAAE;AACpCK,MAAAA,cAAc,CAAC,IAAD,CAAd,CADkC,CACZ;;AACtBF,MAAAA,WAAW,CAAC,KAAD,CAAX,CAFkC,CAEd;;AACpBJ,MAAAA,iBAAiB,GAHiB,CAGb;AACtB;AACF,GAVQ,EAUN,CAACG,QAAD,EAAWF,IAAX,CAVM,CAAT,CAvBsE,CAiCjD;;AAGrB,sBACE,QAAC,gBAAD,CAAkB,QAAlB;AACA,IAAA,KAAK,EAAE;AACLM,MAAAA,OADK;AAELG,MAAAA,OAFK;AAGLP,MAAAA,QAHK;AAILE,MAAAA,WAJK;AAKLM,MAAAA,cALK;AAMLC,MAAAA;AANK,KADP;AAAA,cASGb;AATH;AAAA;AAAA;AAAA;AAAA,UADF;AAaD","sourcesContent":["// Regras de negócio da aplicação; Funções do countdown serão acessadas por outros componentes da aplicação:\n\nimport { createContext, ReactNode, useContext, useEffect, useState } from \"react\"; // useEffect é um hook de efeitos colaterais: quando algo acontecer é disparada alguma função \nimport { ChallengesContext } from \"./ChallengesContext\";\n\ninterface CountdownContextData { // tipos de dados que serão retornados de dentro desse contexto\n  minutes: number;\n  seconds: number;\n  isActive: boolean;\n  hasFinished: boolean;\n  startCountdown: () => void;\n  resetCountdown: () => void;\n}\n\ninterface CountdownProviderProps {\n  children: ReactNode;\n}\n\n\nexport const CountdownContext = createContext({} as CountdownContextData);\n\nlet countdownTimeout: NodeJS.Timeout;  // tipagem global da variável para definir qual o formato dela\n\nexport function CountdownProvider({ children }: CountdownProviderProps) {\n  // o countdown que iniciará um novo challenge\n  const { startNewChallenge } = useContext(ChallengesContext); // desestruturando o contexto\n  const [time, setTime] = useState(25 * 60); // tempo inicial do countdown em segundos\n  const [isActive, setIsActive] = useState(); // armazena a informação de quando o countdown está acontecendo/ativo\n  const [hasFinished, setHasFinished] = useState(false); // inicia como false porque essa condição será setada depois \n  const minutes = Math.floor(time / 60); // arredondando pra baixo, desconsiderando segundos restantes\n  const seconds = time % 60; // resto da divisão pra considerar os segundos restantes \n\n  function startCountdown() {\n    setIsActive(true); // no começo precisa ativar o countdown, então ao clicar no botão será setado o valor\n  }\n\n  // a função tem o objetivo de suspender, então partir desse momento vai parar de executar\n  function resetCountdown() { // porém quando parar o countdown, a função abaixo já terá executado - 1, nesse caso incluir a variável countdownTimeout pra tratar esse detalhe    \n    clearTimeout(countdownTimeout) // quando resetar o countdown, dar um clear passando a variável countdownTimeout cancelando assim sua execução\n    setIsActive(false); // parando de executar\n    setHasFinished(false); // voltando para a condição inicial do countdown\n    setTime(25 * 60) // quando for parado o countdown, o setTime deve ser atualizado e o time deve voltar para seu estado inicial\n  } \n\n  // 1º parâmetro: função do que quero executar, 2º parâmetro: quando quero executar\n  // nesse caso executar a função startCountDown sempre que o valor de active mudar\n  useEffect( () => {\n    if (isActive && time > 0) { // se estou com countdown ativo e time for maior que 0\n      countdownTimeout = setTimeout(() => { // a variável irá armazenar a função nativa setTimeout dispara outra função aqui uma arrow function, no tempo que for definido, nesse caso, 1 segundo\n        setTime(time - 1); // essa arrow function tira 1 segundo do time e atualiza o setTime \n      }, 1000)\n    }  else if (isActive && time === 0) { // verificando se o countdown chegou até o final\n      setHasFinished(true); // aqui o estado setHasFinished será atualizado\n      setIsActive(false); // e o contdown não estará mais ativo\n      startNewChallenge(); // quando o time chega a 0, a função startNewChallenge irá disparar um novo desafio\n    }\n  }, [isActive, time]) // além de xecutar toda essa função quando o active mudar, executar também quando o time muda (a cada 1 segundo a função é disparada)\n  \n\n  return (\n    <CountdownContext.Provider \n    value={{\n      minutes,\n      seconds,\n      isActive,\n      hasFinished,\n      startCountdown,\n      resetCountdown\n    }}>\n      {children}\n    </CountdownContext.Provider>\n  )\n}"]},"metadata":{},"sourceType":"module"}