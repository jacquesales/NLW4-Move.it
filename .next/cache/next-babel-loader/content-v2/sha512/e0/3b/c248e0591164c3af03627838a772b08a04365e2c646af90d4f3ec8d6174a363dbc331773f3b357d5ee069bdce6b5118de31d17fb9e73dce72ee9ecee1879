{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/home/jacqueline/Documents/NLW4/moveit-next/src/contexts/CountdownContext.tsx\",\n    _s = $RefreshSig$();\n\n// Regras de negócio da aplicação; Funções do countdown serão acessadas por outros componentes da aplicação:\nimport { createContext, useContext, useEffect, useState } from \"react\"; // useEffect é um hook de efeitos colaterais: quando algo acontecer é disparada alguma função \n\nimport { ChallengesContext } from \"./ChallengesContext\";\nexport var CountdownContext = /*#__PURE__*/createContext({});\nvar countdownTimeout; // tipagem global da variável para definir qual o formato dela\n\nexport function CountdownProvider(_ref) {\n  _s();\n\n  var children = _ref.children;\n\n  // o countdown que iniciará um novo challenge\n  var _useContext = useContext(ChallengesContext),\n      startNewChallenge = _useContext.startNewChallenge; // desestruturando o contexto\n\n\n  var _useState = useState(0.1 * 60),\n      time = _useState[0],\n      setTime = _useState[1]; // tempo inicial do countdown em segundos\n\n\n  var _useState2 = useState(),\n      isActive = _useState2[0],\n      setIsActive = _useState2[1]; // armazena a informação de quando o countdown está acontecendo/ativo\n\n\n  var _useState3 = useState(false),\n      hasFinished = _useState3[0],\n      setHasFinished = _useState3[1]; // inicia como false porque essa condição será setado depois \n\n\n  var minutes = Math.floor(time / 60); // arredondando pra baixo, desconsiderando segundos restantes\n\n  var seconds = time % 60; // resto da divisão pra considerar os segundos restantes \n\n  function startCountdown() {\n    setIsActive(true); // no começo precisa ativar o countdown, então ao clicar no botão será setado o valor\n  } // a função tem o objetivo de suspender, então partir desse momento vai parar de executar\n\n\n  function resetCountdown() {\n    // porém quando parar o countdown, a função abaixo já terá executado - 1, nesse caso incluir a variável countdownTimeout pra tratar esse detalhe    \n    clearTimeout(countdownTimeout); // quando resetar o countdown, dar um clear passando a variável countdownTimeout cancelando assim sua execução\n\n    setIsActive(false); // parando de executar\n\n    setTime(25 * 60); // quando for parado o countdown, o setTime deve ser atualizado e o time deve voltar para seu estado inicial\n\n    setHasFinished(false);\n  } // 1º parâmetro: função do que quero executar, 2º parâmetro: quando quero executar\n  // nesse caso executar a função startCountDown sempre que o valor de active mudar\n\n\n  useEffect(function () {\n    if (isActive && time > 0) {\n      // se estou com countdown ativo e time for maior que 0\n      countdownTimeout = setTimeout(function () {\n        // a variável irá armazenar a função nativa setTimeout dispara outra função aqui uma arrow function, no tempo que for definido, nesse caso, 1 segundo\n        setTime(time - 1); // essa arrow function tira 1 segundo do time e atualiza o setTime \n      }, 1000);\n    } else if (isActive && time === 0) {\n      // verificando se o countdown chegou até o final\n      setHasFinished(true); // aqui o estado setHasFinished será atualizado\n\n      setIsActive(false); // e o contdown não estará mais ativo\n\n      startNewChallenge(); // quando o time chega a 0, a função startNewChallenge irá disparar um novo desafio\n    }\n  }, [isActive, time]); // além de xecutar toda essa função quando o active mudar, executar também quando o time muda (a cada 1 segundo a função é disparada)\n\n  return /*#__PURE__*/_jsxDEV(CountdownContext.Provider, {\n    value: {\n      minutes: minutes,\n      seconds: seconds,\n      isActive: isActive,\n      hasFinished: hasFinished,\n      startCountdown: startCountdown,\n      resetCountdown: resetCountdown\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 61,\n    columnNumber: 5\n  }, this);\n}\n\n_s(CountdownProvider, \"nSXr9TMurlofRwN11Xw8oP+oCBs=\");\n\n_c = CountdownProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"CountdownProvider\");","map":{"version":3,"sources":["/home/jacqueline/Documents/NLW4/moveit-next/src/contexts/CountdownContext.tsx"],"names":["createContext","useContext","useEffect","useState","ChallengesContext","CountdownContext","countdownTimeout","CountdownProvider","children","startNewChallenge","time","setTime","isActive","setIsActive","hasFinished","setHasFinished","minutes","Math","floor","seconds","startCountdown","resetCountdown","clearTimeout","setTimeout"],"mappings":";;;;;AAAA;AAEA,SAASA,aAAT,EAAmCC,UAAnC,EAA+CC,SAA/C,EAA0DC,QAA1D,QAA0E,OAA1E,C,CAAmF;;AACnF,SAASC,iBAAT,QAAkC,qBAAlC;AAgBA,OAAO,IAAMC,gBAAgB,gBAAGL,aAAa,CAAC,EAAD,CAAtC;AAEP,IAAIM,gBAAJ,C,CAAuC;;AAEvC,OAAO,SAASC,iBAAT,OAAiE;AAAA;;AAAA,MAApCC,QAAoC,QAApCA,QAAoC;;AACtE;AADsE,oBAExCP,UAAU,CAACG,iBAAD,CAF8B;AAAA,MAE9DK,iBAF8D,eAE9DA,iBAF8D,EAET;;;AAFS,kBAG9CN,QAAQ,CAAC,MAAM,EAAP,CAHsC;AAAA,MAG/DO,IAH+D;AAAA,MAGzDC,OAHyD,iBAG1B;;;AAH0B,mBAItCR,QAAQ,EAJ8B;AAAA,MAI/DS,QAJ+D;AAAA,MAIrDC,WAJqD,kBAI1B;;;AAJ0B,mBAKhCV,QAAQ,CAAC,KAAD,CALwB;AAAA,MAK/DW,WAL+D;AAAA,MAKlDC,cALkD,kBAKf;;;AACvD,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWR,IAAI,GAAG,EAAlB,CAAhB,CANsE,CAM/B;;AACvC,MAAMS,OAAO,GAAGT,IAAI,GAAG,EAAvB,CAPsE,CAO3C;;AAE3B,WAASU,cAAT,GAA0B;AACxBP,IAAAA,WAAW,CAAC,IAAD,CAAX,CADwB,CACL;AACpB,GAXqE,CAatE;;;AACA,WAASQ,cAAT,GAA0B;AAAE;AAC1BC,IAAAA,YAAY,CAAChB,gBAAD,CAAZ,CADwB,CACO;;AAC/BO,IAAAA,WAAW,CAAC,KAAD,CAAX,CAFwB,CAEJ;;AACpBF,IAAAA,OAAO,CAAC,KAAK,EAAN,CAAP,CAHwB,CAGP;;AACjBI,IAAAA,cAAc,CAAC,KAAD,CAAd;AACD,GAnBqE,CAqBtE;AACA;;;AACAb,EAAAA,SAAS,CAAE,YAAM;AACf,QAAIU,QAAQ,IAAIF,IAAI,GAAG,CAAvB,EAA0B;AAAE;AAC1BJ,MAAAA,gBAAgB,GAAGiB,UAAU,CAAC,YAAM;AAAE;AACpCZ,QAAAA,OAAO,CAACD,IAAI,GAAG,CAAR,CAAP,CADkC,CACf;AACpB,OAF4B,EAE1B,IAF0B,CAA7B;AAGD,KAJD,MAIQ,IAAIE,QAAQ,IAAIF,IAAI,KAAK,CAAzB,EAA4B;AAAE;AACpCK,MAAAA,cAAc,CAAC,IAAD,CAAd,CADkC,CACZ;;AACtBF,MAAAA,WAAW,CAAC,KAAD,CAAX,CAFkC,CAEd;;AACpBJ,MAAAA,iBAAiB,GAHiB,CAGb;AACtB;AACF,GAVQ,EAUN,CAACG,QAAD,EAAWF,IAAX,CAVM,CAAT,CAvBsE,CAiCjD;;AAGrB,sBACE,QAAC,gBAAD,CAAkB,QAAlB;AACA,IAAA,KAAK,EAAE;AACLM,MAAAA,OAAO,EAAPA,OADK;AAELG,MAAAA,OAAO,EAAPA,OAFK;AAGLP,MAAAA,QAAQ,EAARA,QAHK;AAILE,MAAAA,WAAW,EAAXA,WAJK;AAKLM,MAAAA,cAAc,EAAdA,cALK;AAMLC,MAAAA,cAAc,EAAdA;AANK,KADP;AAAA,cASGb;AATH;AAAA;AAAA;AAAA;AAAA,UADF;AAaD;;GAjDeD,iB;;KAAAA,iB","sourcesContent":["// Regras de negócio da aplicação; Funções do countdown serão acessadas por outros componentes da aplicação:\n\nimport { createContext, ReactNode, useContext, useEffect, useState } from \"react\"; // useEffect é um hook de efeitos colaterais: quando algo acontecer é disparada alguma função \nimport { ChallengesContext } from \"./ChallengesContext\";\n\ninterface CountdownContextData { // tipos de dados que serão retornados de dentro desse contexto\n  minutes: number;\n  seconds: number;\n  isActive: boolean;\n  hasFinished: boolean;\n  startCountdown: () => void;\n  resetCountdown: () => void;\n}\n\ninterface CountdownProviderProps {\n  children: ReactNode;\n}\n\n\nexport const CountdownContext = createContext({} as CountdownContextData);\n\nlet countdownTimeout: NodeJS.Timeout;  // tipagem global da variável para definir qual o formato dela\n\nexport function CountdownProvider({ children }: CountdownProviderProps) {\n  // o countdown que iniciará um novo challenge\n  const { startNewChallenge } = useContext(ChallengesContext); // desestruturando o contexto\n  const [time, setTime] = useState(0.1 * 60); // tempo inicial do countdown em segundos\n  const [isActive, setIsActive] = useState(); // armazena a informação de quando o countdown está acontecendo/ativo\n  const [hasFinished, setHasFinished] = useState(false); // inicia como false porque essa condição será setado depois \n  const minutes = Math.floor(time / 60); // arredondando pra baixo, desconsiderando segundos restantes\n  const seconds = time % 60; // resto da divisão pra considerar os segundos restantes \n\n  function startCountdown() {\n    setIsActive(true); // no começo precisa ativar o countdown, então ao clicar no botão será setado o valor\n  }\n\n  // a função tem o objetivo de suspender, então partir desse momento vai parar de executar\n  function resetCountdown() { // porém quando parar o countdown, a função abaixo já terá executado - 1, nesse caso incluir a variável countdownTimeout pra tratar esse detalhe    \n    clearTimeout(countdownTimeout) // quando resetar o countdown, dar um clear passando a variável countdownTimeout cancelando assim sua execução\n    setIsActive(false); // parando de executar\n    setTime(25 * 60) // quando for parado o countdown, o setTime deve ser atualizado e o time deve voltar para seu estado inicial\n    setHasFinished(false);\n  } \n\n  // 1º parâmetro: função do que quero executar, 2º parâmetro: quando quero executar\n  // nesse caso executar a função startCountDown sempre que o valor de active mudar\n  useEffect( () => {\n    if (isActive && time > 0) { // se estou com countdown ativo e time for maior que 0\n      countdownTimeout = setTimeout(() => { // a variável irá armazenar a função nativa setTimeout dispara outra função aqui uma arrow function, no tempo que for definido, nesse caso, 1 segundo\n        setTime(time - 1); // essa arrow function tira 1 segundo do time e atualiza o setTime \n      }, 1000)\n    }  else if (isActive && time === 0) { // verificando se o countdown chegou até o final\n      setHasFinished(true); // aqui o estado setHasFinished será atualizado\n      setIsActive(false); // e o contdown não estará mais ativo\n      startNewChallenge(); // quando o time chega a 0, a função startNewChallenge irá disparar um novo desafio\n    }\n  }, [isActive, time]) // além de xecutar toda essa função quando o active mudar, executar também quando o time muda (a cada 1 segundo a função é disparada)\n  \n\n  return (\n    <CountdownContext.Provider \n    value={{\n      minutes,\n      seconds,\n      isActive,\n      hasFinished,\n      startCountdown,\n      resetCountdown\n    }}>\n      {children}\n    </CountdownContext.Provider>\n  )\n}"]},"metadata":{},"sourceType":"module"}